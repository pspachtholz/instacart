ggplot(aes(x=days_since_prior_order)) +
geom_histogram(stat="count",fill="red")
orders %>% filter(eval_set=="prior") %>% count(order_number) %>% ggplot(aes(order_number,n)) + geom_line(color="red", size=1)+geom_point(size=2, color="red")
order_products %>%
group_by(order_id) %>%
summarize(n_items = last(add_to_cart_order)) %>%
ggplot(aes(x=n_items))+
geom_histogram(stat="count",fill="red") +
geom_rug()+
coord_cartesian(xlim=c(0,80))
order_products_prior %>%
group_by(order_id) %>%
summarize(n_items = last(add_to_cart_order)) %>%
ggplot(aes(x=n_items))+
geom_histogram(stat="count",fill="red") +
geom_rug() +
coord_cartesian(xlim=c(0,80))
tmp <- order_products %>%
group_by(product_id) %>%
summarize(count = n()) %>%
top_n(10, wt = count) %>%
left_join(select(products,product_id,product_name),by="product_id") %>%
arrange(desc(count))
kable(tmp)
tmp %>%
ggplot(aes(x=reorder(product_name,-count), y=count))+
geom_bar(stat="identity",fill="red")+
theme(axis.text.x=element_text(angle=90, hjust=1),axis.title.x = element_blank())
tmp <- order_products %>%
group_by(reordered) %>%
summarize(count = n()) %>%
mutate(reordered = as.factor(reordered)) %>%
mutate(proportion = count/sum(count))
kable(tmp)
tmp %>%
ggplot(aes(x=reordered,y=count,fill=reordered))+
geom_bar(stat="identity")
tmp <-order_products %>%
group_by(product_id) %>%
summarize(proportion_reordered = mean(reordered), n=n()) %>%
filter(n>40) %>%
top_n(10,wt=proportion_reordered) %>%
arrange(desc(proportion_reordered)) %>%
left_join(products,by="product_id")
kable(tmp)
tmp %>%
ggplot(aes(x=reorder(product_name,-proportion_reordered), y=proportion_reordered))+
geom_bar(stat="identity",fill="red")+
theme(axis.text.x=element_text(angle=90, hjust=1),axis.title.x = element_blank())+coord_cartesian(ylim=c(0.85,0.95))
tmp <- order_products %>%
group_by(product_id, add_to_cart_order) %>%
summarize(count = n()) %>% mutate(pct=count/sum(count)) %>%
filter(add_to_cart_order == 1, count>10) %>%
arrange(desc(pct)) %>%
left_join(products,by="product_id") %>%
select(product_name, pct, count) %>%
ungroup() %>%
top_n(10, wt=pct)
kable(tmp)
tmp %>%
ggplot(aes(x=reorder(product_name,-pct), y=pct))+
geom_bar(stat="identity",fill="red")+
theme(axis.text.x=element_text(angle=90, hjust=1),axis.title.x = element_blank())+coord_cartesian(ylim=c(0.4,0.7))
order_products %>%
left_join(orders,by="order_id") %>%
group_by(days_since_prior_order) %>%
summarize(mean_reorder = mean(reordered)) %>%
ggplot(aes(x=days_since_prior_order,y=mean_reorder))+
geom_bar(stat="identity",fill="red")
order_products %>%
group_by(product_id) %>%
summarize(proportion_reordered = mean(reordered), n=n()) %>%
ggplot(aes(x=n,y=proportion_reordered))+
geom_point()+
geom_smooth(color="red")+
coord_cartesian(xlim=c(0,2000))
products
head(products)
str_detect(str_to_lower(products$product_name),'organic')
sum(str_detect(str_to_lower(products$product_name),'organic'))
sum(str_detect(products$product_name,'organic'))
sum(str_detect(products$product_name,'Organic'))
install.packages(c("curl", "DBI", "dplyr", "evaluate", "ggExtra", "quantmod", "R6", "rgdal", "rmarkdown", "shinyjs", "sp", "visNetwork", "XML"))
devtools::install_github("Microsoft/LightGBM", subdir = "R-package")
install.packages("devtools")
devtools::install_github("Microsoft/LightGBM", subdir = "R-package")
devtools::install_github("Microsoft/LightGBM", subdir = "R-package")
devtools::install_github("Microsoft/LightGBM", subdir = "R-package")
devtools::install_github("Microsoft/LightGBM@v1", subdir = "R-package")
devtools::install_github("Microsoft/LightGBM", subdir = "R-package")
devtools::install_github("Laurae2/lgbdl")
lgb.dl(commit = "master",
compiler = "gcc",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
library(lgbdl)
lgb.dl(commit = "master",
compiler = "gcc",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
compiler = "gcc",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4)
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4, compiler="gcc")
lgb.dl(commit = "master",
repo = "https://github.com/Microsoft/LightGBM",
cores = 4, compiler="gcc")
require(lightgbm)
require(methods)
# Load in the agaricus dataset
data(agaricus.train, package = "lightgbm")
data(agaricus.test, package = "lightgbm")
dtrain <- lgb.Dataset(agaricus.train$data, label = agaricus.train$label)
dtest <- lgb.Dataset(agaricus.test$data, label = agaricus.test$label)
valids <- list(eval = dtest, train = dtrain)
#--------------------Advanced features ---------------------------
# advanced: start from a initial base prediction
print("Start running example to start from a initial prediction")
# Train lightgbm for 1 round
param <- list(num_leaves = 4,
learning_rate = 1,
nthread = 2,
objective = "binary")
bst <- lgb.train(param, dtrain, 1, valids = valids)
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
# Note: we need the margin value instead of transformed prediction in set_init_score
ptrain <- predict(bst, agaricus.train$data, rawscore = TRUE)
ptest  <- predict(bst, agaricus.test$data, rawscore = TRUE)
# set the init_score property of dtrain and dtest
# base margin is the base prediction we will boost from
setinfo(dtrain, "init_score", ptrain)
setinfo(dtest, "init_score", ptest)
print("This is result of boost from initial prediction")
bst <- lgb.train(params = param,
data = dtrain,
nrounds = 5,
valids = valids)
?setinfo
install.packages("dplyr")
install.packages("dplyr")
install.packages("data.table")
rm(list=ls())
gc()
library(data.table)
library(dplyr)
library(tidyr)
library(xgboost)
library(stringr)
library(ModelMetrics)
library(ggplot2)
#setwd("D:/Eigene Dateien/sonstiges/Kaggle/instacart/scripts")
f1 <- function (y, pred)
{
tp <- sum(pred==1 & y == 1)
fp <- sum(pred==1 & y == 0)
fn <- sum(pred==0 & y == 1)
precision <- ifelse ((tp==0 & fp==0), 0, tp/(tp+fp)) # no reorders predicted
recall <- ifelse ((tp==0 & fn==0), 0, tp/(tp+fn)) # no products reordered
score <- ifelse((all(pred==0) & all(y==0)),1,ifelse((precision==0 & recall==0),0,2*precision*recall/(precision+recall)))
score
}
# Load Data ---------------------------------------------------------------
path <- "../input"
aisles <- fread(file.path(path, "aisles.csv"))
departments <- fread(file.path(path, "departments.csv"))
opp <- fread(file.path(path, "order_products__prior.csv"))
opt <- fread(file.path(path, "order_products__train.csv"))
ord <- fread(file.path(path, "orders.csv"))
products <- fread(file.path(path, "products.csv"))
# add user_id to train orders
opt$user_id <- ord$user_id[match(opt$order_id, ord$order_id)]
train_info <- opt[,.(sum_products = .N, sum_reordered=sum(reordered)),user_id]
# join products with order info for all prior orders
setkey(opp,order_id)
setkey(ord,order_id)
op <- merge(ord,opp,all=FALSE) # inner join filter
rm(opp)
gc()
# Get the only reorderes ------------------------------
reorder_users <- op[order_number>1 & .N>2,.(mean_reordered = mean(reordered), n=.N), user_id][mean_reordered==1,user_id]
gc()
# Take subset of Data ----------------------------------------------------
test_users <- unique(ord[eval_set=="test", user_id])
train_users <- unique(ord[eval_set=="train", user_id]) #& !user_id %in% reorder_users
n_users <- 15000
all_train_users <- train_users[1:n_users]
all_users <- c(all_train_users, test_users)
setkeyv(op,c("user_id","product_id", "order_number"))
op[,last_prior_order := max(order_number),.(user_id)]
ord[,last_order := max(order_number),.(user_id)] # auch train/test orders mit drin
#op<-op[last_prior_order-order_number <= 2] #last order = last prior order
#ord<-ord[last_order-order_number <= 3]
setkey(ord, user_id, order_number)
ord[order(order_number), ':=' (order_days_sum = cumsum(ifelse(is.na(days_since_prior_order),0,days_since_prior_order))),user_id][,':=' (order_days_max=max(order_days_sum)),user_id][, ':=' (order_day_year = 365-(order_days_max-order_days_sum)),user_id]
op <- merge(op, ord[,.(user_id, order_number, order_days_sum, order_days_max, order_day_year)], all.x=T)
op[order(user_id, product_id, order_number), ':=' (
product_time = 1:.N,
first_order = min(order_number),
second_order = order_number[2],
third_order = order_number[3],
up_sum_order = .N), .(user_id,product_id)]
op[(reordered==1 | product_time==1),':=' (order_days_lag=c(NA,order_days_sum[-.N])), .(user_id, product_id)]
setwd("D:/Eigene Dateien/sonstiges/Kaggle/instacart/scripts")
rm(list=ls())
gc()
library(data.table)
library(dplyr)
library(tidyr)
library(xgboost)
library(stringr)
library(ModelMetrics)
library(ggplot2)
#setwd("D:/Eigene Dateien/sonstiges/Kaggle/instacart/scripts")
f1 <- function (y, pred)
{
tp <- sum(pred==1 & y == 1)
fp <- sum(pred==1 & y == 0)
fn <- sum(pred==0 & y == 1)
precision <- ifelse ((tp==0 & fp==0), 0, tp/(tp+fp)) # no reorders predicted
recall <- ifelse ((tp==0 & fn==0), 0, tp/(tp+fn)) # no products reordered
score <- ifelse((all(pred==0) & all(y==0)),1,ifelse((precision==0 & recall==0),0,2*precision*recall/(precision+recall)))
score
}
# Load Data ---------------------------------------------------------------
path <- "../input"
aisles <- fread(file.path(path, "aisles.csv"))
departments <- fread(file.path(path, "departments.csv"))
opp <- fread(file.path(path, "order_products__prior.csv"))
opt <- fread(file.path(path, "order_products__train.csv"))
ord <- fread(file.path(path, "orders.csv"))
products <- fread(file.path(path, "products.csv"))
# add user_id to train orders
opt$user_id <- ord$user_id[match(opt$order_id, ord$order_id)]
train_info <- opt[,.(sum_products = .N, sum_reordered=sum(reordered)),user_id]
# join products with order info for all prior orders
setkey(opp,order_id)
setkey(ord,order_id)
op <- merge(ord,opp,all=FALSE) # inner join filter
rm(opp)
gc()
# Get the only reorderes ------------------------------
reorder_users <- op[order_number>1 & .N>2,.(mean_reordered = mean(reordered), n=.N), user_id][mean_reordered==1,user_id]
gc()
# Take subset of Data ----------------------------------------------------
test_users <- unique(ord[eval_set=="test", user_id])
train_users <- unique(ord[eval_set=="train", user_id]) #& !user_id %in% reorder_users
n_users <- 15000
all_train_users <- train_users[1:n_users]
all_users <- c(all_train_users, test_users)
setkeyv(op,c("user_id","product_id", "order_number"))
op[,last_prior_order := max(order_number),.(user_id)]
ord[,last_order := max(order_number),.(user_id)] # auch train/test orders mit drin
#op<-op[last_prior_order-order_number <= 2] #last order = last prior order
#ord<-ord[last_order-order_number <= 3]
setkey(ord, user_id, order_number)
ord[order(order_number), ':=' (order_days_sum = cumsum(ifelse(is.na(days_since_prior_order),0,days_since_prior_order))),user_id][,':=' (order_days_max=max(order_days_sum)),user_id][, ':=' (order_day_year = 365-(order_days_max-order_days_sum)),user_id]
op <- merge(op, ord[,.(user_id, order_number, order_days_sum, order_days_max, order_day_year)], all.x=T)
op[order(user_id, product_id, order_number), ':=' (
product_time = 1:.N,
first_order = min(order_number),
second_order = order_number[2],
third_order = order_number[3],
up_sum_order = .N), .(user_id,product_id)]
op[(reordered==1 | product_time==1),':=' (order_days_lag=c(NA,order_days_sum[-.N])), .(user_id, product_id)]
opt
ord
ord[user_id==1][order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N, .(user_id)]
ord[order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N, .(user_id)]
ord[user_id==1][order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N), .(user_id)]
ord[user_id==2][order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N), .(user_id)]
ord[user_id==3][order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N), .(user_id)]
ord[user_id==4][order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N), .(user_id)]
ord[user_id==5][order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N), .(user_id)]
ord[order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N, .(user_id)]
od <- ord[order(user_id, order_number), .(order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N), .(user_id)]
od
hist(od$order_dow_typicality)
ord
range(ord$order_hour_of_day)
tmp <- ord[order(user_id,order_number), .(
order_hod_typicality = order_hour_of_day-order_hour_of_day[.N]
, .(user_id, order_number))]
od <- ord[order(user_id, order_number), .(
order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N)
, .(user_id)]
od
us <- ord[order(user_id, order_number), .(
train_order_dow_typicality = (sum(order_dow==order_dow[.N])-1)/.N)
, .(user_id)]
tmp <- ord[order(user_id,order_number), .(
order_hod_typicality = order_hour_of_day[.N]
, .(user_id, order_number))]
tmp
ord
tmp <- ord[order(user_id,order_number), .(
order_hod_typicality = .N)
, .(user_id, order_number)]
tmp
tmp <- ord[order(user_id,order_number), .(
order_hod_typicality = order_number[.N])
, .(user_id)]
tmp
tmp <- ord[order(user_id,order_number), .(
order_hod_typicality = order_hour_of_day[.N])
, .(user_id)]
tmp
tmp <- ord[order(user_id,order_number), .(
order_hod_typicality = 1:.N)
, .(user_id, order_id)]
tmp
tmp <- ord[order(user_id,order_number), .(order_number,
order_hod_typicality = 1:.N)
, .(user_id, order_id)]
tmp
tmp <- ord[order(user_id,order_number), .(order_number,
order_hod_typicality = 1:.N)
, .(user_id)]
tmp
